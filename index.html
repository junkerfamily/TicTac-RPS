<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RPS Tic-Tac-Toe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 10px;
            overflow-x: hidden;
        }

        .container {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 100%;
            width: 100%;
            max-height: none; /* allow full document height so board isn't clipped */
            overflow-y: visible;
            padding-bottom: 24px;
        }

        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            body {
                padding: 5px;
                min-height: 100vh;
                align-items: flex-start;
                padding-top: 10px;
            }
            
            .container {
                padding: 10px;
                border-radius: 10px;
                max-height: calc(100vh - 10px);
                overflow-y: auto;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 8px;
                border-radius: 8px;
            }
        }

        /* Desktop layout constraints */
        @media (min-width: 1024px) {
            .container {
                max-width: 760px;
                padding-bottom: 240px; /* keep room for sticky stats + reset */
            }
            .board {
                max-width: 520px;
            }
            .stats {
                position: sticky;
                bottom: 64px; /* sit above sticky reset button */
                z-index: 4;
                background: white;
                padding-top: 6px;
            }
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        h1 {
            color: #333;
            font-size: 1.8em;
            margin: 0;
            flex: 1;
            text-align: center;
        }

        .rules-btn {
            background: #667eea;
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .rules-btn:hover {
            background: #764ba2;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        /* Mobile header adjustments */
        @media (max-width: 768px) {
            .header {
                margin-bottom: 12px;
            }
            
            h1 {
                font-size: 1.5em;
            }
            
            .rules-btn {
                width: 35px;
                height: 35px;
                font-size: 1.1em;
            }
        }

        @media (max-width: 480px) {
            .header {
                margin-bottom: 10px;
            }
            
            h1 {
                font-size: 1.3em;
            }
            
            .rules-btn {
                width: 32px;
                height: 32px;
                font-size: 1em;
            }
        }

        .turn-indicator {
            text-align: center;
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 15px;
            padding: 8px;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        /* Mobile typography adjustments */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.5em;
                margin-bottom: 12px;
            }
            
            .turn-indicator {
                font-size: 1.1em;
                margin-bottom: 12px;
                padding: 6px;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.3em;
                margin-bottom: 10px;
            }
            
            .turn-indicator {
                font-size: 1em;
                margin-bottom: 10px;
                padding: 5px;
            }
        }

        .turn-indicator.red {
            background: #ff6b6b;
            color: white;
        }

        .turn-indicator.blue {
            background: #4ecdc4;
            color: white;
        }

        .piece-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .piece-btn {
            padding: 8px;
            font-size: 2.5em;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f0f0f0;
            min-width: 80px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Mobile piece selector */
        @media (max-width: 768px) {
            .piece-selector {
                gap: 8px;
                margin-bottom: 12px;
            }
            
            .piece-btn {
                padding: 6px;
                font-size: 2em;
                min-width: 70px;
                min-height: 70px;
            }
        }

        @media (max-width: 480px) {
            .piece-selector {
                gap: 6px;
                margin-bottom: 10px;
            }
            
            .piece-btn {
                padding: 4px;
                font-size: 1.8em;
                min-width: 60px;
                min-height: 60px;
            }
        }

        .piece-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .piece-btn.selected {
            border-color: #333;
            background: #fff;
            transform: scale(1.15);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 15px auto;
            max-width: 100%;
            width: 100%;
        }

        .cell {
            aspect-ratio: 1;
            border: 2px solid #ddd;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: var(--cell-font-size, 2.5em);
            line-height: 1;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
            min-height: 60px;
            touch-action: manipulation;
        }

        /* Mobile board optimization */
        @media (max-width: 768px) {
            .board {
                gap: 6px;
                margin: 12px auto;
                width: 85vw;         /* make cells ~15% smaller on mobile */
                max-width: 85vw;
            }
            
            .cell {
                min-height: 50px;
                border-radius: 6px;
            }
        }

        @media (max-width: 480px) {
            .board {
                gap: 4px;
                margin: 10px auto;
                width: 85vw;         /* keep ~15% smaller on small phones */
                max-width: 85vw;
            }
            
            .cell {
                min-height: 45px;
                border-radius: 5px;
            }
        }

        /* Ensure board fits on small screens */
        @media (max-width: 360px) {
            .cell {
                min-height: 40px;
            }
        }

        .cell:hover:not(.occupied) {
            background: #f9f9f9;
            border-color: #999;
        }

        .cell.red {
            background: #ffe0e0;
            border-color: #ff6b6b;
        }

        .cell.blue {
            background: #e0f7f5;
            border-color: #4ecdc4;
        }

        .cell.capturable {
            animation: pulse 1s infinite;
            cursor: pointer;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .cell.selected-for-capture {
            border-color: #ffd700;
            border-width: 5px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
            margin-top: 12px; /* ensure it always sits below the board */
        }

        .stat-box {
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        /* Mobile stats optimization */
        @media (max-width: 768px) {
            .stats {
                gap: 8px;
                margin-bottom: 12px;
            }
            
            .stat-box {
                padding: 10px;
                border-radius: 6px;
            }
        }

        @media (max-width: 480px) {
            .stats {
                gap: 6px;
                margin-bottom: 10px;
            }
            
            .stat-box {
                padding: 8px;
                border-radius: 5px;
            }
        }

        .stat-box.red {
            background: #ff6b6b;
            color: white;
        }

        .stat-box.blue {
            background: #4ecdc4;
            color: white;
        }

        .stat-box h3 {
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-box .number {
            font-size: 2em;
            font-weight: bold;
        }

        .reset-btn {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            touch-action: manipulation;
            margin-top: 14px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.06);
        }

        /* Mobile button optimization */
        @media (max-width: 768px) {
            .reset-btn {
                padding: 10px;
                font-size: 1em;
                border-radius: 6px;
            }
        }

        @media (max-width: 480px) {
            .reset-btn {
                padding: 8px;
                font-size: 0.9em;
                border-radius: 5px;
            }
        }

        .reset-btn:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .game-mode {
            text-align: center;
            font-size: 0.9em;
            color: #666;
            margin-top: 10px;
            font-style: italic;
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .mode-btn {
            padding: 8px 16px;
            font-size: 0.9em;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            background: white;
            transition: all 0.3s ease;
            touch-action: manipulation;
            flex: 1;
            max-width: 120px;
        }

        /* Mobile mode selector */
        @media (max-width: 768px) {
            .mode-selector {
                gap: 6px;
                margin-bottom: 10px;
            }
            
            .mode-btn {
                padding: 6px 12px;
                font-size: 0.8em;
                border-radius: 5px;
                max-width: 100px;
            }
        }

        @media (max-width: 480px) {
            .mode-selector {
                gap: 4px;
                margin-bottom: 8px;
            }
            
            .mode-btn {
                padding: 5px 10px;
                font-size: 0.75em;
                border-radius: 4px;
                max-width: 90px;
            }
        }

        .mode-btn:hover {
            border-color: #999;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .cell.moveable {
            animation: bounce 0.5s ease infinite;
            cursor: pointer;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .cell.valid-move {
            background: #fff8dc !important;
            border-color: #ffd700 !important;
            cursor: pointer;
        }

        .winner-banner {
            position: relative;
            background: white;
            padding: 20px 24px;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
            z-index: 1;
            text-align: center;
            animation: slideIn 0.3s ease;
            max-width: 800px;
            width: 100%;
            margin: 8px auto 16px auto; /* sits above selectors, below header */
        }

        /* Mobile winner banner */
        @media (max-width: 768px) {
            .winner-banner {
                padding: 16px 18px;
                border-radius: 10px;
                max-width: 95%;
            }
        }

        @media (max-width: 480px) {
            .winner-banner {
                padding: 12px 16px;
                border-radius: 10px;
                max-width: 98%;
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .winner-banner h2 {
            font-size: 2em;
            margin-bottom: 15px;
        }

        /* Mobile winner banner text */
        @media (max-width: 768px) {
            .winner-banner h2 {
                font-size: 1.8em;
                margin-bottom: 12px;
            }
        }

        @media (max-width: 480px) {
            .winner-banner h2 {
                font-size: 1.5em;
                margin-bottom: 10px;
            }
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 999;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%) translateY(120%);
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 10px 16px;
            border-radius: 9999px;
            font-size: 0.95em;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            z-index: 2000;
            opacity: 0;
            transition: transform 0.25s ease, opacity 0.25s ease;
            pointer-events: none;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        /* Rules Popover Styles */
        .rules-popover {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.4);
            z-index: 1001;
            max-width: 90%;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideIn 0.3s ease;
        }

        .rules-popover h2 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.8em;
        }

        .rules-content {
            line-height: 1.6;
            color: #555;
        }

        .rules-content h3 {
            color: #667eea;
            margin: 20px 0 10px 0;
            font-size: 1.2em;
        }

        .rules-content ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .rules-content li {
            margin: 8px 0;
        }

        .rules-content .emoji {
            font-size: 1.2em;
            margin-right: 8px;
        }

        .close-rules-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #ff6b6b;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .close-rules-btn:hover {
            background: #ff5252;
            transform: scale(1.1);
        }

        /* Mobile rules popover */
        @media (max-width: 768px) {
            .rules-popover {
                padding: 20px;
                border-radius: 12px;
                max-width: 95%;
                max-height: 85vh;
            }
            
            .rules-popover h2 {
                font-size: 1.5em;
                margin-bottom: 15px;
            }
            
            .rules-content h3 {
                font-size: 1.1em;
                margin: 15px 0 8px 0;
            }
        }

        @media (max-width: 480px) {
            .rules-popover {
                padding: 15px;
                border-radius: 10px;
                max-width: 98%;
                max-height: 90vh;
            }
            
            .rules-popover h2 {
                font-size: 1.3em;
                margin-bottom: 12px;
            }
            
            .rules-content h3 {
                font-size: 1em;
                margin: 12px 0 6px 0;
            }
            
            .close-rules-btn {
                width: 25px;
                height: 25px;
                font-size: 1em;
                top: 10px;
                right: 10px;
            }
        }

        /* Additional mobile optimizations */
        @media (max-width: 768px) {
            .game-mode {
                font-size: 0.8em;
                margin-top: 8px;
            }
            
            .stat-box h3 {
                font-size: 0.8em;
                margin-bottom: 3px;
            }
            
            .stat-box .number {
                font-size: 1.5em;
            }
        }

        @media (max-width: 480px) {
            .game-mode {
                font-size: 0.75em;
                margin-top: 6px;
            }
            
            .stat-box h3 {
                font-size: 0.75em;
                margin-bottom: 2px;
            }
            
            .stat-box .number {
                font-size: 1.3em;
            }
        }

        /* Prevent zoom on double tap for mobile */
        * {
            touch-action: manipulation;
        }

        /* Ensure proper scrolling on mobile */
        @media (max-width: 768px) {
            body {
                -webkit-overflow-scrolling: touch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎮 RPS Tic-Tac-Toe</h1>
            <button class="rules-btn" onclick="toggleRules()" title="Game Rules">❓</button>
        </div>
        
        <div class="turn-indicator" id="turnIndicator">Red's Turn</div>
        
        <div class="mode-selector">
            <button class="mode-btn active" id="placeBtn" onclick="setMode('place')">Place Piece</button>
            <button class="mode-btn" id="moveBtn" onclick="setMode('move')">Move Piece</button>
        </div>

        <div class="piece-selector" id="pieceSelector">
            <button class="piece-btn" data-piece="rock">🪨</button>
            <button class="piece-btn" data-piece="paper">📄</button>
            <button class="piece-btn" data-piece="scissors">✂️</button>
        </div>

        <div class="game-mode" id="gameMode">Select a piece and place it on the board</div>
        
        <div class="board" id="board"></div>
        
        <div class="stats">
            <div class="stat-box red">
                <h3>Red Captures/Wins</h3>
                <div class="number" id="redStats">0 | 0</div>
            </div>
            <div class="stat-box blue">
                <h3>Blue Captures/Wins</h3>
                <div class="number" id="blueStats">0 | 0</div>
            </div>
        </div>
        
        <button class="reset-btn" onclick="resetGame()">Reset Game</button>
    </div>

    <!-- Rules Popover -->
    <div class="rules-popover" id="rulesPopover" style="display: none;">
        <button class="close-rules-btn" onclick="toggleRules()">×</button>
        <h2>🎮 How to Play RPS Tic-Tac-Toe</h2>
        <div class="rules-content">
            <h3>🎯 Objective</h3>
            <p>Get three of your pieces in a row (horizontally, vertically, or diagonally) to win! But there's a twist - pieces can capture each other using Rock-Paper-Scissors rules.</p>
            
            <h3>🪨📄✂️ Rock-Paper-Scissors Rules</h3>
            <ul>
                <li><span class="emoji">🪨</span> Rock beats Scissors</li>
                <li><span class="emoji">📄</span> Paper beats Rock</li>
                <li><span class="emoji">✂️</span> Scissors beats Paper</li>
            </ul>
            
            <h3>🎮 Game Modes</h3>
            <p><strong>Place Piece:</strong> Select a piece type (Rock, Paper, or Scissors) and place it on an empty square.</p>
            <p><strong>Move Piece:</strong> Move one of your existing pieces to an adjacent empty square. Moving consumes your turn.</p>
            
            <h3>⚔️ Capturing</h3>
            <p>After placing or moving a piece, if you can capture an opponent's piece using RPS rules, you'll enter capture mode. You can only capture pieces that are adjacent (sharing an edge) or diagonally adjacent (kitty-corner) to your piece. Capturing consumes your turn.</p>
            <p><strong>Adjacent positions:</strong> Up, down, left, right, and all 4 diagonal corners from your piece.</p>
            <p>Click your piece, then click the adjacent opponent's piece to capture it!</p>
            
            <h3>🏆 Winning</h3>
            <ul>
                <li><strong>Regular Win:</strong> Get 3 pieces in a row (+1 point)</li>
                <li><strong>Special Win:</strong> Get 3 of the SAME piece type in a row (+2 points!)</li>
                <li><strong>Draw:</strong> Board fills up with no winner</li>
            </ul>
            
            <h3>💡 Tips</h3>
            <ul>
                <li>Plan your captures strategically</li>
                <li>Try to get special wins for bonus points</li>
                <li>Block your opponent's winning moves</li>
                <li>Use movement to set up powerful captures</li>
            </ul>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast" aria-live="polite" aria-atomic="true"></div>

    <script>
        const pieceEmojis = {
            rock: '🪨',
            paper: '📄',
            scissors: '✂️'
        };

        let gameState = {
            board: Array(9).fill(null),
            currentPlayer: 'red',
            selectedPiece: null,
            captureMode: false,
            selectedCaptureCell: null,
            redCaptures: 0,
            blueCaptures: 0,
            redWins: 0,
            blueWins: 0,
            gameOver: false,
            turnMode: 'place',
            selectedMoveCell: null
        };

        function initBoard() {
            const board = document.getElementById('board');
            board.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.index = i;
                cell.onclick = () => handleCellClick(i);
                board.appendChild(cell);
            }
            // Ensure fonts are sized after initial render
            requestAnimationFrame(resizeCellFonts);
        }

        function updateBoard() {
            gameState.board.forEach((cell, i) => {
                const cellEl = document.querySelector(`[data-index="${i}"]`);
                if (cell) {
                    cellEl.textContent = pieceEmojis[cell.piece];
                    cellEl.className = `cell ${cell.player} occupied`;
                } else {
                    cellEl.textContent = '';
                    cellEl.className = 'cell';
                }
            });
            
            highlightMovement();
            resizeCellFonts();
        }

        function updateUI() {
            const turnIndicator = document.getElementById('turnIndicator');
            turnIndicator.textContent = `${gameState.currentPlayer === 'red' ? 'Red' : 'Blue'}'s Turn`;
            turnIndicator.className = `turn-indicator ${gameState.currentPlayer}`;
            
            const redStatsEl = document.getElementById('redStats');
            const blueStatsEl = document.getElementById('blueStats');
            if (redStatsEl) redStatsEl.textContent = `${gameState.redCaptures} | ${gameState.redWins}`;
            if (blueStatsEl) blueStatsEl.textContent = `${gameState.blueCaptures} | ${gameState.blueWins}`;
            
            const gameMode = document.getElementById('gameMode');
            if (gameState.captureMode) {
                if (gameState.selectedCaptureCell !== null) {
                    gameMode.textContent = 'Click an opponent piece to capture it';
                } else {
                    gameMode.textContent = 'Click your piece to attempt a capture';
                }
            } else if (gameState.turnMode === 'move') {
                if (gameState.selectedMoveCell !== null) {
                    gameMode.textContent = 'Click an adjacent empty square to move';
                } else {
                    gameMode.textContent = 'Click your piece to move it';
                }
            } else {
                gameMode.textContent = 'Select a piece and place it on the board';
            }
            
            document.getElementById('pieceSelector').style.display = 
                (gameState.captureMode || gameState.turnMode === 'move') ? 'none' : 'flex';
        }

        function showToast(message) {
            const el = document.getElementById('toast');
            if (!el) return;
            el.textContent = message;
            el.classList.add('show');
            clearTimeout(showToast._t);
            showToast._t = setTimeout(() => el.classList.remove('show'), 1500);
        }

        document.querySelectorAll('.piece-btn').forEach(btn => {
            btn.onclick = () => {
                if (gameState.gameOver || gameState.captureMode) return;
                
                document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                gameState.selectedPiece = btn.dataset.piece;
            };
        });

        function canCapture(attacker, defender) {
            if (attacker === 'rock') return defender === 'scissors';
            if (attacker === 'paper') return defender === 'rock';
            if (attacker === 'scissors') return defender === 'paper';
            return false;
        }

        function isAdjacent(index1, index2) {
            const row1 = Math.floor(index1 / 3);
            const col1 = index1 % 3;
            const row2 = Math.floor(index2 / 3);
            const col2 = index2 % 3;
            
            const rowDiff = Math.abs(row1 - row2);
            const colDiff = Math.abs(col1 - col2);
            
            // Adjacent if they're next to each other horizontally, vertically, or diagonally
            return (rowDiff <= 1 && colDiff <= 1) && !(rowDiff === 0 && colDiff === 0);
        }

        function checkCapturePossible() {
            for (let i = 0; i < 9; i++) {
                const cell = gameState.board[i];
                if (cell && cell.player === gameState.currentPlayer) {
                    for (let j = 0; j < 9; j++) {
                        const target = gameState.board[j];
                        if (target && target.player !== gameState.currentPlayer && 
                            isAdjacent(i, j) && canCapture(cell.piece, target.piece)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function highlightCapturablePieces() {
            document.querySelectorAll('.cell').forEach(cellEl => {
                cellEl.classList.remove('capturable', 'selected-for-capture');
            });
            
            if (!gameState.captureMode) return;
            
            if (gameState.selectedCaptureCell === null) {
                for (let i = 0; i < 9; i++) {
                    const cell = gameState.board[i];
                    if (cell && cell.player === gameState.currentPlayer) {
                        for (let j = 0; j < 9; j++) {
                            const target = gameState.board[j];
                            if (target && target.player !== gameState.currentPlayer && 
                                isAdjacent(i, j) && canCapture(cell.piece, target.piece)) {
                                document.querySelector(`[data-index="${i}"]`).classList.add('capturable');
                                break;
                            }
                        }
                    }
                }
            } else {
                const attackerCell = gameState.board[gameState.selectedCaptureCell];
                document.querySelector(`[data-index="${gameState.selectedCaptureCell}"]`).classList.add('selected-for-capture');
                
                for (let j = 0; j < 9; j++) {
                    const target = gameState.board[j];
                    if (target && target.player !== gameState.currentPlayer && 
                        isAdjacent(gameState.selectedCaptureCell, j) && canCapture(attackerCell.piece, target.piece)) {
                        document.querySelector(`[data-index="${j}"]`).classList.add('capturable');
                    }
                }
            }
        }

        function setMode(mode) {
            if (gameState.gameOver || gameState.captureMode) return;
            
            gameState.turnMode = mode;
            gameState.selectedPiece = null;
            gameState.selectedMoveCell = null;
            
            document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            
            if (mode === 'place') {
                document.getElementById('placeBtn').classList.add('active');
            } else {
                document.getElementById('moveBtn').classList.add('active');
            }
            
            updateUI();
            updateBoard();
        }

        function getAdjacentCells(index) {
            const row = Math.floor(index / 3);
            const col = index % 3;
            const adjacent = [];
            
            if (row > 0) adjacent.push(index - 3);
            if (row < 2) adjacent.push(index + 3);
            if (col > 0) adjacent.push(index - 1);
            if (col < 2) adjacent.push(index + 1);
            
            return adjacent;
        }

        function highlightMovement() {
            document.querySelectorAll('.cell').forEach(cellEl => {
                cellEl.classList.remove('moveable', 'valid-move');
            });
            
            if (gameState.turnMode !== 'move' || gameState.captureMode) return;
            
            if (gameState.selectedMoveCell === null) {
                for (let i = 0; i < 9; i++) {
                    const cell = gameState.board[i];
                    if (cell && cell.player === gameState.currentPlayer) {
                        const adjacent = getAdjacentCells(i);
                        const hasEmptyAdjacent = adjacent.some(adj => !gameState.board[adj]);
                        if (hasEmptyAdjacent) {
                            document.querySelector(`[data-index="${i}"]`).classList.add('moveable');
                        }
                    }
                }
            } else {
                document.querySelector(`[data-index="${gameState.selectedMoveCell}"]`).classList.add('selected-for-capture');
                const adjacent = getAdjacentCells(gameState.selectedMoveCell);
                adjacent.forEach(adj => {
                    if (!gameState.board[adj]) {
                        document.querySelector(`[data-index="${adj}"]`).classList.add('valid-move');
                    }
                });
            }
        }

        function handleCellClick(index) {
            if (gameState.gameOver) return;
            
            const cell = gameState.board[index];
            
            // Allow initiating a capture directly by clicking your piece
            // even if we're not already in capture mode (and not in move mode)
            if (!gameState.captureMode && gameState.turnMode !== 'move') {
                if (cell && cell.player === gameState.currentPlayer) {
                    let canCaptureAny = false;
                    for (let j = 0; j < 9; j++) {
                        const target = gameState.board[j];
                        if (target && target.player !== gameState.currentPlayer &&
                            isAdjacent(index, j) && canCapture(cell.piece, target.piece)) {
                            canCaptureAny = true;
                            break;
                        }
                    }
                    if (canCaptureAny) {
                        gameState.captureMode = true;
                        gameState.selectedCaptureCell = index;
                        highlightCapturablePieces();
                        updateUI();
                        return;
                    }
                }
            }

            if (gameState.captureMode) {
                if (gameState.selectedCaptureCell === null) {
                    if (cell && cell.player === gameState.currentPlayer) {
                        let canCaptureAny = false;
                        for (let j = 0; j < 9; j++) {
                            const target = gameState.board[j];
                            if (target && target.player !== gameState.currentPlayer && 
                                isAdjacent(index, j) && canCapture(cell.piece, target.piece)) {
                                canCaptureAny = true;
                                break;
                            }
                        }
                        if (canCaptureAny) {
                            gameState.selectedCaptureCell = index;
                            highlightCapturablePieces();
                        }
                    }
                } else {
                    const attackerCell = gameState.board[gameState.selectedCaptureCell];
                    if (cell && cell.player !== gameState.currentPlayer && 
                        isAdjacent(gameState.selectedCaptureCell, index) && canCapture(attackerCell.piece, cell.piece)) {
                        gameState.board[index] = attackerCell;
                        gameState.board[gameState.selectedCaptureCell] = null;
                        
                        if (gameState.currentPlayer === 'red') {
                            gameState.redCaptures++;
                        } else {
                            gameState.blueCaptures++;
                        }
                        
                        gameState.captureMode = false;
                        gameState.selectedCaptureCell = null;
                        updateBoard();
                        
                        // Check win after capture
                        if (checkWinner()) {
                            return;
                        }
                        
                        // Capturing consumes the turn
                        gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
                        gameState.turnMode = 'place';
                        showToast(`${gameState.currentPlayer === 'red' ? 'Red' : 'Blue'}'s turn`);
                        updateUI();
                    }
                }
            } else if (gameState.turnMode === 'move') {
                if (gameState.selectedMoveCell === null) {
                    if (cell && cell.player === gameState.currentPlayer) {
                        const adjacent = getAdjacentCells(index);
                        const hasEmptyAdjacent = adjacent.some(adj => !gameState.board[adj]);
                        if (hasEmptyAdjacent) {
                            gameState.selectedMoveCell = index;
                            updateBoard();
                        }
                    }
                } else {
                    const adjacent = getAdjacentCells(gameState.selectedMoveCell);
                    if (!cell && adjacent.includes(index)) {
                        gameState.board[index] = gameState.board[gameState.selectedMoveCell];
                        gameState.board[gameState.selectedMoveCell] = null;
                        
                        updateBoard();
                        
                        if (checkWinner()) {
                            return;
                        }
                        
                        gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
                        gameState.selectedMoveCell = null;
                        gameState.turnMode = 'place';
                        setMode('place');
                        showToast(`${gameState.currentPlayer === 'red' ? 'Red' : 'Blue'}'s turn`);
                        updateUI();
                    }
                }
            } else {
                if (!cell && gameState.selectedPiece) {
                    gameState.board[index] = {
                        player: gameState.currentPlayer,
                        piece: gameState.selectedPiece
                    };
                    
                    updateBoard();
                    
                    if (checkWinner()) {
                        return;
                    }
                    
                    gameState.currentPlayer = gameState.currentPlayer === 'red' ? 'blue' : 'red';
                    gameState.selectedPiece = null;
                    document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
                    
                    gameState.turnMode = 'place';
                    setMode('place');
                    showToast(`${gameState.currentPlayer === 'red' ? 'Red' : 'Blue'}'s turn`);
                    updateUI();
                }
            }
        }

        function checkWinner() {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            
            for (const [a, b, c] of lines) {
                if (gameState.board[a] && gameState.board[b] && gameState.board[c]) {
                    if (gameState.board[a].player === gameState.board[b].player &&
                        gameState.board[a].player === gameState.board[c].player) {
                        
                        // Check if all 3 pieces are the same type (special win)
                        if (gameState.board[a].piece === gameState.board[b].piece &&
                            gameState.board[a].piece === gameState.board[c].piece) {
                            showWinner(gameState.board[a].player, true);
                            return true;
                        } else {
                            showWinner(gameState.board[a].player, false);
                            return true;
                        }
                    }
                }
            }
            
            if (gameState.board.every(cell => cell !== null)) {
                showWinner('draw', false);
                return true;
            }
            
            return false;
        }

        function showWinner(winner, isSpecial) {
            gameState.gameOver = true;
            
            if (winner !== 'draw') {
                const points = isSpecial ? 2 : 1;
                if (winner === 'red') {
                    gameState.redWins += points;
                } else {
                    gameState.blueWins += points;
                }
            }
            
            const banner = document.createElement('div');
            banner.className = 'winner-banner';
            
            if (winner === 'draw') {
                banner.innerHTML = `
                    <h2>It's a Draw!</h2>
                    <button class="reset-btn" onclick="closeWinnerBanner()">Play Again</button>
                `;
            } else {
                const winType = isSpecial ? 
                    '<p style="font-size: 1.2em; margin-top: 10px;">🎉 SPECIAL WIN! 3 matching pieces! +2 points 🎉</p>' : 
                    '';
                banner.innerHTML = `
                    <h2 style="color: ${winner === 'red' ? '#ff6b6b' : '#4ecdc4'}">${winner === 'red' ? 'Red' : 'Blue'} Wins!</h2>
                    ${winType}
                    <button class="reset-btn" onclick="closeWinnerBanner()">Play Again</button>
                `;
            }
            
            const container = document.querySelector('.container');
            const insertBeforeEl = document.querySelector('.mode-selector');
            if (container && insertBeforeEl) {
                container.insertBefore(banner, insertBeforeEl);
            } else {
                document.body.appendChild(banner);
            }
            
            updateUI();
        }

        function closeWinnerBanner() {
            const banner = document.querySelector('.winner-banner');
            if (banner) banner.remove();
            resetGame();
        }

        function resetGame() {
            gameState.board = Array(9).fill(null);
            gameState.currentPlayer = 'red';
            gameState.selectedPiece = null;
            gameState.captureMode = false;
            gameState.selectedCaptureCell = null;
            gameState.gameOver = false;
            gameState.turnMode = 'place';
            gameState.selectedMoveCell = null;
            
            document.querySelectorAll('.piece-btn').forEach(b => b.classList.remove('selected'));
            setMode('place');
            
            updateBoard();
            updateUI();
        }

        function toggleRules() {
            const rulesPopover = document.getElementById('rulesPopover');
            const isVisible = rulesPopover.style.display !== 'none';
            
            if (isVisible) {
                rulesPopover.style.display = 'none';
                document.body.style.overflow = 'auto';
            } else {
                rulesPopover.style.display = 'block';
                document.body.style.overflow = 'hidden';
            }
        }

        // Close rules when clicking outside
        document.addEventListener('click', function(event) {
            const rulesPopover = document.getElementById('rulesPopover');
            const rulesBtn = document.querySelector('.rules-btn');
            
            if (rulesPopover.style.display !== 'none' && 
                !rulesPopover.contains(event.target) && 
                !rulesBtn.contains(event.target)) {
                toggleRules();
            }
        });

        // Close rules with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const rulesPopover = document.getElementById('rulesPopover');
                if (rulesPopover.style.display !== 'none') {
                    toggleRules();
                }
            }
        });

        initBoard();
        updateUI();

        function resizeCellFonts() {
            const board = document.getElementById('board');
            if (!board) return;
            const cells = board.querySelectorAll('.cell');
            if (cells.length === 0) return;
            const firstCell = cells[0];
            const cellSize = Math.min(firstCell.clientWidth, firstCell.clientHeight);
            if (!cellSize) return;
            // Make emoji large but leave a little padding
            const fontSizePx = Math.floor(cellSize * 0.55);
            cells.forEach(el => {
                el.style.setProperty('--cell-font-size', fontSizePx + 'px');
            });
        }

        window.addEventListener('resize', resizeCellFonts);
        window.addEventListener('orientationchange', resizeCellFonts);
        // Ensure sizing once DOM and styles are fully applied
        window.addEventListener('load', resizeCellFonts);
    </script>
</body>
</html>